# 设计模式七大原则
  - 单一职责原则: 降低类的复杂度,一个类只负责一项职责

  - 接口隔离原则: 一个类对另一个类的依赖应该建立在最小的接口上,不应该依赖它不需要的接口,即类依赖的接口中有很多个方法都没用到,那么按照接口隔离原则,
  应该将这个接口拆分为两个接口,一个是包含全部需要用到的方法的接口和一个未用到方法的接口,我们的类只需要依赖于用到的方法的接口,这样才满足接口隔离原则;
    假设我们现在有一个interface1,其中有五个抽象方法method1-5,现在有接口b和接口d实现了interface1,并重写了其五个方法,而现在我们有类A和类C,
  其方法分别依赖于接口b的m1、m2、m3方法和接口d的m1、m4和m5方法,那现在这个代码的结构就不符合我们的接口隔离原则;用类A和接口b来解释,类A依赖于接口b
  中的m1、m2、m3,但是m4和m5并未依赖,那相当于对于类A对接口b的依赖,只需要依赖3个接口,但是接口b实际提供了5个接口,不符合建立在最小接口的理念;
    即若想满足最小接口,则接口b只应该重写m1、m2、m3三个方法,则应有该interface1、interface2和interface3,interface1中只有m1这一个方法,然后在
  interface2中有m2、m3两个方法,interface3中只有m4、m5两个方法,接口b实现interface1和interface2、接口d去实现interface1和interface3,这样
  类A和类C在依赖于接口b和d时,也就满足了最小接口的要求;

  - 依赖倒转原则: 中心思想是面向接口编程,高层模块不应该依赖底层模块,二者都应该依赖其抽象

  - 里氏替换原则: 强调子类继承父类后,尽量不要重写父类的方法;即里氏替换原则不希望出现父类和子类执行相同的方法时出现截然不同的结果;例如类B继承了类A,
  A中的test方法: test(int x, int y) {return x-y},而B中的test方法: test(int x, int y) {return x + y},这种就违背了里氏替换原则需要注意,
  里氏替换原则并非focus抽象类,而是focus两个可以实例化的类,不该出现A继承B,重写方法后,发现A和B的方法结果不同的情况,如果你希望一个方法有不同的实现,
  会有很多更优解,比如共同继承某个抽象类,或是实现某个接口等;本质上里氏替换原则还是在规避一些容易造成错误的写法,虽然有一定开发经验的人都不会用那种诡异
  的方式;

  - 开闭原则: 一个类的模块和函数应该对扩展开放,对修改关闭,用抽象构建框架,用实现扩展细节

  - 迪米特法则: 又称最少知道法则,即一个类对自己依赖的类知道的越少越好;类与类之间关系越密切,耦合度就越大;迪米特法则希望陌生的类最好不要以局部变量的
  形式出现在另一个类的内部,即不要出现public class B { method() { int c = A.m(); return c+6; } },这种情况;但是我发现实际开发中,我写代码
  经常会出现这种情况,往往是缺什么就直接调个接口去查,然后把信息一装填,以后需要考虑迪米特法则;

  - 合成复用原则: 尽量使用合成/聚合的方式,而不是使用继承
    如果我们希望让B类去使用A类的方法,如果使用继承的方式就会让B和A之间的耦合性较强,我们可以采取
    - 合成的方式: B{method(A a)}的方式
    - 聚合的方式: class B{private A a, method(A a) {this.a = a}}的方式来实现需求;