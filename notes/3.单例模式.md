# 单例模式
  ## 单例模式的概念
  所谓单例设计模式,就是采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例,并且该类只提供一个获取其对象实例的方法
  
  ## 单例模式的写法
  ### 饿汉式(静态常量)
  - 饿汉式(静态常量),实现步骤如下:
    - 构造器私有化
    - 类的内部创建一个对象
    - 向外暴露一个静态的公共方法
  - [饿汉式(静态常量)代码实现:](/src/main/java/com/kul/singleton/type1/SingletonTest01.java)
  - 饿汉式的优点
    - 写法比较简单,并且在类装载就完成了实例化,避免了线程同步问题
  - 饿汉式的缺点
    - 在类装载时就完成实例化,没有达到懒加载的效果,如果从始至终从未使用过这个实例,则会造成内存的浪费

  ### 饿汉式(静态代码块)
  - 饿汉式(静态常量),实现步骤如下: 
    - 构造器私有化
    - 类的内部创建一个静态变量,通过静态代码块创建实例
    - 向外暴露一个静态的公共方法
  - [饿汉式(静态代码块)代码实现](/src/main/java/com/kul/singleton/type2/SingletonTest02.java)
  - 饿汉式的静态代码块实现方式与静态常量的实现方式本质没有什么不同,优缺点也一致,如果非要说有什么区别,那就是静态常量的方式实现实例化是在类的准备阶段,而静态代码块的方式实现实例化
是在初始化的阶段

  ### 懒汉式(线程不安全)
  - 懒汉式(线程不安全),实现步骤如下:
    - 构造器私有化
    - 类的内部创建一个静态变量
    - 对外暴露一个静态的公共方法,在方法中通过判断instance是否为null,决定是否要将其实例化
  - [懒汉式(线程不安全)代码实现](/src/main/java/com/kul/singleton/type3/SingletonTest03.java)
  - 该种写法虽然起到了懒加载的作用,但只适用于单线程场景,在多线程场景下,一个线程进入了if(singleton == null)判断语句块,还未来得及往下执行,另一个线程也通过了这个判断语句,这时
  便会产生多个实例,所以在多线程环境下不可使用这种方式;实际开发中也不会使用这种方式;

  ### 懒汉式(线程安全)
  - 懒汉式(线程安全),实现步骤如下:
    - 构造器私有化
    - 类的内部创建一个静态变量
    - 对外暴露一个静态的公共方法,在方法中通过判断instance是否为null,决定是否要将其实例化,并通过对该静态方法加锁来保证线程安全
  - [懒汉式(线程安全)代码实现](/src/main/java/com/kul/singleton/type4/SingletonTest04.java)
  - 虽然既保证了延迟加载,又保证了线程安全,但是作为一个常用方法来说,synchronized修饰会导致效率过低的问题,所以在实际开发中,也并不推荐该方式

  ### 懒汉式(双重检查)
  - 懒汉式(双重检查),实现步骤如下:
    - 构造器私有化
    - 类的内部创建一个由volatile修饰的静态变量
    - 对外暴露一个静态的公共方法,在方法中通过在synchronized前后两次对if(instance == null)的判断来保证线程安全
  - [懒汉式(双重检查)代码实现](/src/main/java/com/kul/singleton/type5/SingletonTest05.java)
  - 该方案通过引入volatile保证在大多数情况下,仅通过第一次判断就可以实现多线程下实例的单例返回,但volatile并不能完全保证线程安全,所以在第一次判断后,通过synchronized修饰
  又进行了第二次判断,这种方式使得大多数即使多线程场景下,也可以依赖volatile的可见性实现正确的单例返回,而少数情况又有synchronized兜底,可以说既保证了懒加载和效率,又保证了
  线程安全,是很推荐的一种写法;

  ### 静态内部类
  - 静态内部类,实现步骤如下:
    - 构造器私有化
    - 创建一个静态内部类,并在该类中设置一个外部类声明的final的私有对象的声明
    - 对外暴露一个静态的公共方法,在方法中返回单例对象;
  - [静态内部类代码实现](/src/main/java/com/kul/singleton/type6/SingletonTest06.java)
  - 首先要明确,静态内部类的特点就是在外部类加载时,并不会加载静态内部类,即静态内部类的加载只在其首次被使用时触发,并且因为JVM在装载类时是线程安全的,所以这种写法也是既保证了懒加载,
  又保证了线程安全;所以这种方式也是比较推荐使用的;

  ### 枚举
  - 枚举,实现步骤如下:
    - 创建一个枚举类,和枚举类的一个枚举实例
    - 调用该枚举类的枚举实例即为一个单例对象
  - [枚举代码实现](/src/main/java/com/kul/singleton/type7/SingletonTest07.java)
  - 这种写法不仅能避免多线程问题,还可以防止反序列化重新创建新的对象,这种方式也是非常推荐使用的;不过这种方式没法实现懒加载,因为枚举类的实例在类加载时就被创建